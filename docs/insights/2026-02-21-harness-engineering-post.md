# 코드 에이전트 시대, 왜 하네스 엔지니어링이 필요했는가

요즘은 직접 코드를 한 줄씩 치는 시간보다, 코드 에이전트에게 일을 맡기는 시간이 점점 늘어나고 있습니다.  
저도 같은 흐름 안에 있었고, 그 과정에서 아주 현실적인 문제를 계속 겪었습니다.

- 계획은 잘 나오는데 구현으로 안 이어지는 경우
- 버그를 고친다고 했는데 원인 말고 증상만 건드리는 경우
- 세션이 바뀌면 맥락이 끊겨서 같은 설명을 반복하는 경우
- 문서가 많아졌는데 오히려 중요한 기준을 찾기 어려운 경우

이 문제를 해결하려고 이 프로젝트에 **Harness Engineering**을 단계적으로 적용했습니다.

---

## 하네스 엔지니어링이란?

복잡하게 들릴 수 있지만, 실무적으로는 간단합니다.

**"에이전트가 일하는 환경과 규칙을 설계해서, 좋은 결과가 반복되게 만드는 것"**

즉, 프롬프트 한 번 잘 쓰는 것이 아니라 다음을 시스템으로 고정하는 일입니다.

1. 어떤 문서를 먼저 읽을지
2. 언제 계획하고 언제 구현할지
3. 실패했을 때 어떻게 재시도할지
4. 완료 기준을 어디에 기록할지

---

## 우리가 실제로 바꾼 것

### 1) 문서 구조를 "얇은 루트 + 계층 문서"로 재구성

처음에는 루트 문서(AGENTS)에 이것저것 다 들어가 있었습니다.  
결과적으로 기준이 섞이고 유지보수가 어려웠습니다.

그래서 다음처럼 바꿨습니다.

- 루트(`AGENTS.md`): 핵심 규칙만
- 상세 규칙: `docs/agent-layers/*`
- 실행 템플릿: `docs/harness/templates/*`
- 작업 결과 기록: `docs/changes/*`
- 과거 실험 자료: `docs/harness/legacy/*`

핵심은 **규칙은 짧게, 실행은 템플릿으로**입니다.

### 2) AI-Lint를 "명령"이 아니라 "루프"로 운영

`lint` 한 번 돌려서 끝내면 실제로는 품질 개선이 잘 안 됩니다.  
그래서 다음 루프로 고정했습니다.

- 1차: 자동 수정 가능한 것 처리
- 2~3차: 수동 구조 수정
- 실패 시: blocker와 원인 기록

이 방식으로 기존 경고(예: `<img>` 관련 경고, 미사용 변수)를 실제로 정리하고, `lint:ci`, `build`, `e2e`까지 통과시켰습니다.

### 3) "계획만 하고 끝나는" 패턴 차단

계획 문서가 좋아도 구현으로 안 넘어가면 가치가 없습니다.  
그래서 규칙을 명시했습니다.

- 계획 승인 후 기본값은 즉시 구현
- 진짜로 계획만 필요한 경우에만 예외
- 템플릿에 `Implementation Trigger`, `Stop Condition` 필수

### 4) 버그 수정은 무조건 원인 가설부터

버그가 나면 일단 고치고 보는 습관이 반복 비용을 키웠습니다.  
이제는 다음 순서를 강제합니다.

1. Root Cause Hypothesis 작성
2. Evidence(근거) 확인
3. 코드 수정
4. 검증

같은 접근이 두 번 실패하면, 세 번째는 새 가설로 다시 시작합니다.

### 5) "작업 단위 체크포인트"를 남기게 함

세션이 바뀌어도 잃지 않게 하려면 흔적이 남아야 합니다.

작업 단위마다 최소 3가지를 남기도록 했습니다.

- 커밋
- 변경 리포트(`docs/changes/*`)
- 검증 결과(lint/build/e2e)

---

## 가장 큰 인사이트

### 인사이트 1: 좋은 에이전트보다 좋은 컨텍스트 구조가 먼저다

모델 성능보다, 무엇을 어디에 기록하고 어떻게 참조하게 하는지가 결과를 더 크게 바꿨습니다.

### 인사이트 2: 규칙은 길게 쓰는 게 아니라 "충돌 없이" 유지되는 게 중요하다

문서를 많이 쓰는 것보다, 중복을 없애고 단일 기준(Source of Truth)을 유지하는 게 훨씬 중요했습니다.

### 인사이트 3: Soft Gate가 초기 도입에 현실적이다

처음부터 모든 규칙을 강제(Hard Gate)하면 팀이 버틸 수 없습니다.  
우선 Soft Gate로 시작하고, 운영 데이터가 쌓이면 점진 강화하는 방식이 효과적이었습니다.

---

## 하네스 엔지니어링을 처음 적용하는 개발자를 위한 최소 체크리스트

아래 5가지만 먼저 해도 체감이 큽니다.

1. 계획 템플릿과 결과 템플릿을 분리해서 만든다.
2. "계획 승인 후 구현" 규칙을 명시한다.
3. 버그 수정 전에 원인 가설/근거를 쓰게 한다.
4. lint를 단발 명령이 아니라 재시도 루프로 설계한다.
5. 작업 단위 체크포인트(커밋 + 리포트 + 검증)를 남긴다.

---

## 마무리

코드 에이전트 시대의 핵심은 “더 많이 생성”이 아니라 **더 잘 운영**입니다.  
결국 경쟁력은 모델 그 자체보다, 팀이 축적해온 고품질 컨텍스트와 실행 규칙에서 나옵니다.

저희가 NEXUS에서 하네스 엔지니어링을 계속 다듬는 이유도 여기 있습니다.

**좋은 코드는 한 번 만들어지지만, 좋은 컨텍스트는 계속 재사용되며 팀의 속도를 바꿉니다.**
